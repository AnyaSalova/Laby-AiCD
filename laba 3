'''С клавиатуры вводится два числа K и N. Квадратная матрица А(N,N),
состоящая из 4-х равных по размерам подматриц, B,C,D,E заполняется
случайным образом целыми числами в интервале [-10,10]. Для тестирования
использовать не случайное заполнение, а целенаправленное.
Для ИСТд-11 вид матрицы А
B	C
D	E

24.	Формируется матрица F следующим образом: если в Е количество чисел,
больших К в четных столбцах в области 2 больше, чем произведение чисел
в нечетных строках в области 4, то поменять в С симметрично области 1 и 2 местами,
иначе С и В поменять местами несимметрично. При этом матрица А не меняется.
После чего вычисляется выражение: К*(A*F)+ K* F T .
Выводятся по мере формирования А, F и все матричные операции последовательно.
'''

import random

def create_matrix(N):
    """
    Создание квадратной матрицы размера N x N.
    """
    return [[random.randint(-10, 10) for _ in range(N)] for _ in range(N)]

def print_matrix(matrix):
    """
    Вывод матрицы на экран.
    """
    for row in matrix:
        print(' '.join(map(str, row)))
    print()

def count_el_bigger_k(matrix, k):
    """
    Подсчет количества элементов больших k в матрице.
    """
    count = 0
    for row in matrix:
        for num in row:
            if num > k:
                count += 1
    return count

def product_of_numbers_in_odd_strings(matrix):
    """
    Вычисление произведения элементов в нечетных строках матрицы.
    """
    product = 1
    for i in range(1, len(matrix), 2):
        for num in matrix[i]:
            product *= num
    return product

def create_matrix_F(A, B, C, D, E, K):
    """
    Формирование матрицы F согласно условиям задачи.
    """
    F = [row[:] for row in A]  # Копирование матрицы A

    count_el_in_E = count_el_bigger_k(E, K)
    product_of_D_perimeter = product_of_numbers_in_odd_strings(D)

    if count_el_in_E > product_of_D_perimeter:
        for i in range(len(A) // 2):
            for j in range(len(A) // 2):
                C[i][j], C[i + len(A) // 2][j] = C[i + len(A) // 2][j], C[i][j]
    else:
        for i in range(len(A) // 2):
            for j in range(len(A) // 2):
                B[i][j], C[i][j] = C[i][j], B[i][j]

    return F

def multiply_matrix_by_scalar(matrix, scalar):
    """
    Умножение матрицы на скаляр.
    """
    return [[scalar * cell for cell in row] for row in matrix]

def subtract_matrices(A, B):
    """
    Вычитание матриц.
    """
    return [[A[i][j] - B[i][j] for j in range(len(A[i]))] for i in range(len(A))]

def transpose_matrix(matrix):
    """
    Транспонирование матрицы.
    """
    return [list(row) for row in zip(*matrix)]

def main():
    K = int(input("Введите число K: "))
    N = int(input("Введите размерность матрицы N: "))

    if N % 2 != 0:
        print("N должно быть четным.")
        return

    A = create_matrix(N)
    print("Матрица A:")
    print_matrix(A)

    mid = N // 2
    B = [row[:mid] for row in A[:mid]]
    C = [row[mid:] for row in A[:mid]]
    D = [row[:mid] for row in A[mid:]]
    E = [row[mid:] for row in A[mid:]]

    if count_el_bigger_k(E, K) > product_of_numbers_in_odd_strings(D):
        for i in range(mid):
            for j in range(mid):
                E[i][j], E[j][i] = E[j][i], E[i][j]
    else:
        C, B = B, C

    F = [B[i] + C[i] for i in range(mid)] + [D[i] + E[i] for i in range(mid)]

    print("Матрица F после преобразований:")
    print_matrix(F)

    FA = [[sum(a * f for a, f in zip(row, col)) for col in zip(*F)] for row in A]
    F_transposed = transpose_matrix(F)
    KF_transposed = multiply_matrix_by_scalar(F_transposed, K)
    KAF_minus_KFT = subtract_matrices(multiply_matrix_by_scalar(FA, K), KF_transposed)

    # Вывод результатов
    print("Матрица FA (F умноженное на A):")
    print_matrix(FA)

    print("Матрица F транспонированная:")
    print_matrix(F_transposed)

    print("Матрица KFT (K умноженное на F транспонированное):")
    print_matrix(KF_transposed)

    print("Результат выражения K*(A*F) + K*FT:")
    print_matrix(KAF_minus_KFT)

if __name__ == "__main__":
    main()
