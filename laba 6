#1 Задание состоит из двух частей. 
#1 часть – написать программу в соответствии со своим вариантом задания. Написать 2 варианта формирования (алгоритмический и с помощью функций Питона), сравнив по времени их выполнение.
#2 часть – усложнить написанную программу, введя по своему усмотрению в условие минимум одно ограничение на характеристики объектов (которое будет сокращать количество переборов)  и целевую функцию для нахождения оптимального  решения.
# Вариант 24. У няни неограниченное количество  фруктов К разных названий (ф1,…фК). Сформировать (вывести) все возможные варианты меню полдника (1 фрукт) для ребенка на неделю. 

import time
import itertools

#1

def generate_all_menus_algo(fruits, days):
    def backtrack(path, depth):
        if depth == days:
            all_menus.append(path)
            return
        for fruit in fruits:
            backtrack(path + [fruit], depth + 1)

    all_menus = []
    backtrack([], 0)
    return all_menus

# Ввод данных
num_fruits = int(input("Введите количество различных фруктов: "))
fruits = [f"f{i+1}" for i in range(num_fruits)]
days = 7

# Измерение времени выполнения алгоритмического подхода
start_time_algo = time.time()
all_menus_algo = generate_all_menus_algo(fruits, days)
end_time_algo = time.time()

# Вывод результатов алгоритмического подхода
print("Алгоритмический подход:")
for schedule in all_menus_algo:
    print(schedule)
print(f"Время выполнения (алгоритмический подход): {end_time_algo - start_time_algo} секунд")


a = input('нажмите enter для продолжения')

def generate_all_menus_builtin(fruits, days):
    return list(itertools.product(fruits, repeat=days))

# Измерение времени выполнения подхода с использованием встроенных функций
start_time_builtin = time.time()
all_menus_builtin = generate_all_menus_builtin(fruits, days)
end_time_builtin = time.time()

# Вывод результатов подхода с использованием встроенных функций
print("Подход с использованием встроенных функций:")
for schedule in all_menus_builtin:
    print(schedule)
print(f"Время выполнения (встроенные функции): {end_time_builtin - start_time_builtin} секунд")
print(f"Разность по времени выполнения: {abs((end_time_builtin - start_time_builtin) - (end_time_algo - start_time_algo))} секунд")

a = input('нажмите enter для продолжения')


#2 Добавим ограничение: ребенок не должен есть один и тот же фрукт два дня подряд.
# Также добавим целевую функцию для нахождения оптимального решения, например,
# минимизация повторений одного и того же фрукта.

def is_valid_schedule(schedule):
    for i in range(1, len(schedule)):
        if schedule[i] == schedule[i-1]:
            return False
    return True

def target_function(schedule):
    return len(set(schedule))

def find_optimal_menu(fruits, days): #целевая функция
    valid_menus = [menu for menu in itertools.product(fruits, repeat=days) if is_valid_schedule(menu)]
    optimal_menu = max(valid_menus, key=target_function)
    return optimal_menu

# Измерение времени выполнения поиска оптимального меню
start_time_optimal = time.time()
optimal_menu = find_optimal_menu(fruits, days)
end_time_optimal = time.time()

# Вывод результатов алгоритмического подхода
print("Алгоритмический подход усложненной задачи:")
for schedule in all_menus_algo:
    print(schedule)
print(f"Время выполнения усложненной задачи(алгоритмический подход): {end_time_algo - start_time_algo} секунд")

a = input('нажмите enter для продолжения')

# Вывод результатов подхода с использованием встроенных функций
print("Подход с использованием встроенных функций для усложненной задачи:")
for schedule in all_menus_builtin:
    print(schedule)
print(f"Время выполнения усложненной задачи (встроенные функции): {end_time_builtin - start_time_builtin} секунд")
print(f"Разность по времени выполнения: {abs((end_time_builtin - start_time_builtin) - (end_time_algo - start_time_algo))} секунд")

# Вывод оптимального меню
print("Оптимальное меню:")
print(optimal_menu)
print(f"Время выполнения (поиск оптимального меню): {end_time_optimal - start_time_optimal} секунд")
